#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_NUMBER 100

int main() {
  /* Открываем файл или сначала создаем его (если
  такого файла не было). Права доступа к файлу при
  создании определяем как read and write для всех
  категорий пользователей (0666).
  Из-за ошибки в Linux мы будем вынуждены ниже в
  системном вызове mmap() разрешить в
  отображении файла и чтение, и запись,
  хотя реально нам нужна только запись.
  Поэтому и при открытии файла мы вынуждены задавать
  O_RDWR. */
  /* Файловый дескриптор для файла, в
     котором будет храниться информация */
  int fd;
  fd = open("mapped_file", O_RDWR | O_CREAT, 0666);
  if (fd < 0) {
    /* Если файл открыть не удалось, выдаем
       сообщение об ошибке и завершаем работу */
    printf("Can't open a file\n");
    exit(-1);
  }

  // Cтруктура информации, которая будет записана в файл
  struct A {
    int number;
    int square;
  };

  /* Вычисляем будущую длину файла
     (длину отображаемой части файла):
     мы собираемся записать в него 100 структур */
  size_t length = MAX_NUMBER * sizeof(struct A);

  /* Cозданный файл имеет длину 0.
     Если мы его отобразим в память с такой длиной,
     то любая попытка записи в выделенную память
     приведет к ошибке.
     Увеличиваем длину файла с помощью вызова ftruncate(). */
  ftruncate(fd, length);

  /* Указатели на тип структуры для записи в файл.
     ptr будет использоваться в качестве
     начального адреса выделенной области памяти,
     а tmpptr – для перемещения внутри этой области. */
  struct A *ptr, *tmpptr;

  /* Отображаем файл в память.
     Разрешенные операции над отображением
     указываем как PROT_WRITE | PROT_READ
     по уже названным причинам.
     Значение флагов ставим в MAP_SHARED, так как мы хотим
     сохранить информацию, которую занесем в отображение, на диске.
     Файл отображаем с его начала (offset = 0)
     и до конца (length = длине файла). */
  ptr = (struct A*)mmap(NULL, length,
                        PROT_WRITE | PROT_READ,
                        MAP_SHARED, fd, 0);

  // Файловый дескриптор больше не нужен, и мы его закрываем
  close(fd);

  if (ptr == MAP_FAILED) {
    /* Если отобразить файл не удалось,
       сообщаем об ошибке и завершаем работу */
    printf("Mapping failed!\n");
    exit(-1);
  }

  /* В цикле заполняем образ файла числами
     от 0 до 100 и их квадратами.
     Для перемещения по области памяти используем
     указатель tmpptr, так как указатель ptr на
     начало образа файла нам понадобится
     для прекращения отображения вызовом munmap(). */
  tmpptr = ptr;
  int i;
  for (i = 0; i < MAX_NUMBER; i++) {
    tmpptr->number = i;
    tmpptr->square = tmpptr->number * tmpptr->number;
    // printf("%d %d\n", tmpptr->number, tmpptr->square);
    tmpptr++;
  }

  /* Прекращаем отображать файл в память,
     записываем содержимое отображения на диск
     и освобождаем память. */
  if (munmap((void *)ptr, length) < 0) {
    printf("Can't unmap the file\n");
    exit(-1);
  }

  return 0;
}
