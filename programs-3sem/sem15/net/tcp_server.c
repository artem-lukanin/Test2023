/* Пример простого TCP-сервера для сервиса echo */

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define PORT 51000
#define MAX_LEN 1000

void main() {
  // Дескрипторы для слушающего и присоединенного сокетов
  int sockd, newsockd;
  // Создаем TCP-сокет
  if ((sockd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    perror(NULL);
    exit(-1);
  }

  // Структуры для размещения полных адресов сервера и клиента
  struct sockaddr_in servaddr, cliaddr;

  /* Заполняем структуру для адреса сервера:
     семейство протоколов TCP/IP,
     сетевой интерфейс – любой,
     номер порта 51000.
     Поскольку в структуре содержится дополнительное
     не нужное нам поле, которое должно быть нулевым,
     обнуляем ее всю перед заполнением */
  bzero(&servaddr, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_port = htons(PORT);
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

  // Настраиваем адрес сокета
  if (bind(sockd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
    perror(NULL);
    close(sockd);
    exit(-1);
  }

  /* Переводим созданный сокет в пассивное (слушающее) состояние.
     Глубину очереди для установленных соединений описываем значением 5 */
  if (listen(sockd, 5) < 0) {
    perror(NULL);
    close(sockd);
    exit(-1);
  }

  // Длина адреса клиента
  int clilen = 0;
  // Количество принятых символов
  int n = 0;
  // Буфер для приема информации
  char line[MAX_LEN];

  // Основной цикл сервера
  while (1) {
    /* В переменную clilen заносим
       максимальную длину ожидаемого адреса клиента */
    clilen = sizeof(cliaddr);

    /* Ожидаем полностью установленного соединения
       на слушающем сокете.
       При нормальном завершении у нас в структуре cliaddr
       будет лежать полный адрес клиента, установившего соединение,
       а в переменной clilen – его фактическая длина.
       Вызов же вернет дескриптор присоединенного сокета,
       через который будет происходить общение с клиентом.
       Заметим, что информация о клиенте у нас в дальнейшем
       никак не используется, поэтому
       вместо второго и третьего параметров можно было
       поставить значения NULL. */
    if ((newsockd = accept(sockd, (struct sockaddr *) &cliaddr,
                            &clilen)) < 0) {
      perror(NULL);
      close(sockd);
      exit(-1);
    }

    /* В цикле принимаем информацию от клиента до тех пор,
       пока не произойдет ошибки
       (вызов read() вернет отрицательное значение)
       или клиент не закроет соединение
       (вызов read() вернет значение 0).
       Максимальную длину одной порции данных от клиента
       ограничим 999 символами.
       В операциях чтения и записи пользуемся дескриптором
       присоединенного сокета, т. е. значением,
       которое вернул вызов accept().*/
    while ((n = read(newsockd, line, MAX_LEN - 1)) > 0) {
      // Принятые данные отправляем обратно
      if ((n = write(newsockd, line, strlen(line) + 1)) < 0) {
        perror(NULL);
        close(sockd);
        close(newsockd);
        exit(-1);
      }
    }

    /* Если при чтении возникла ошибка – завершаем
    работу */
    if (n < 0) {
      perror(NULL);
      close(sockd);
      close(newsockd);
      exit(-1);
    }

    /* Закрываем дескриптор присоединенного сокета
       и уходим ожидать нового соединения */
    close(newsockd);
  }
}
